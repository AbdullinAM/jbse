<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>JBSE by pietrobraione</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>JBSE</h1>
        <p>A symbolic Java virtual machine for program analysis, verification and test generation.</p>

        <p class="view"><a href="https://github.com/pietrobraione/jbse">View the Project on GitHub <small>pietrobraione/jbse</small></a></p>


        <ul>
          <li><a href="https://github.com/pietrobraione/jbse/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/pietrobraione/jbse/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/pietrobraione/jbse">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h3>
<a id="welcome-to-jbse" class="anchor" href="#welcome-to-jbse" aria-hidden="true"><span class="octicon octicon-link"></span></a>Welcome to JBSE.</h3>

<p>JBSE is the Java Bytecode Symbolic Executor. Basically, it is a special-purpose Java Virtual Machine written in Java.</p>

<h3>
<a id="whats-for" class="anchor" href="#whats-for" aria-hidden="true"><span class="octicon octicon-link"></span></a>What's for?</h3>

<p>JBSE is meant to be used for analyzing your Java code and assess whether it is OK or not. This makes it similar in aim to tools as Checkstyle, PMD or Findbugs, but the analogy ends here. While the above mentioned tools work by scanning the source code in search for errors, JBSE works by simulating the execution of compiled classes (that's why it is a Java Virtual Machine) and analyzing all the conditions that may lead to the coverage of bytecode instructions. In practice, JBSE allows you to specify your custom verification properties by means of assumptions and assertions, and determines whether some program inputs exists that, while satisfying all the assumptions, make fail at least one assertion. In this regard JBSE is a hybrid, static/dynamic analysis tool more similar in spirit, implementation and mode of use to tools like Java Pathfinder, Syreum/Kiasan and JNuke.</p>

<h3>
<a id="what-are-its-distinctive-features" class="anchor" href="#what-are-its-distinctive-features" aria-hidden="true"><span class="octicon octicon-link"></span></a>What are its distinctive features?</h3>

<p>Specifying good verification properties is not always easy, especially when inputs are complex object configurations. To help you in this task JBSE offers a comprehensive set of techniques that none of the tools we are currently aware of offers. </p>

<h3>
<a id="what-are-its-limitations" class="anchor" href="#what-are-its-limitations" aria-hidden="true"><span class="octicon octicon-link"></span></a>What are its limitations?</h3>

<p>Determining whether a path in a program can be covered by some inputs is much harder than scanning the code for error patterns. JBSE works by simulating the execution along a set of program paths. Simulation produces as a result a set of path condititions, that is, formulas on program inputs whose solutions, if they exist, are the input values that cover the program paths that produced them. Then, JBSE checks whether the path conditions have solutions by invoking an external tool. Currently JBSE can interact with Sicstus CLP and with the SMT solvers Z3 and CVC3.</p>

<h3>
<a id="authors-and-contributors" class="anchor" href="#authors-and-contributors" aria-hidden="true"><span class="octicon octicon-link"></span></a>Authors and Contributors</h3>

<p>The contributions to JBSE extend over a very long period, and we lost track to the exact authors of all of them. The current maintainer of JBSE is Pietro Braione (<a href="https://github.com/pietrobraione" class="user-mention">@pietrobraione</a>), with contributions by Giovanni Denaro. Marco Gaboardi wrote the initial implementation. Diego Piazza contributed to develop the Z3 interface.</p>

<h3>
<a id="support-or-contact" class="anchor" href="#support-or-contact" aria-hidden="true"><span class="octicon octicon-link"></span></a>Support or Contact</h3>

<p>For any issue contact Pietro Braione.</p>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/pietrobraione">pietrobraione</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-33854666-2");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>
