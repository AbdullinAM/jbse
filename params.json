{"name":"JBSE","tagline":"A symbolic Java virtual machine for program analysis, verification and test generation.","body":"### Welcome to JBSE\r\nJBSE is the Java Bytecode Symbolic Executor. Basically, it is a special-purpose Java Virtual Machine written in Java.\r\n\r\n### What's for?\r\nJBSE is meant to be used for analyzing Java code and assessing whether it is OK or not. This makes it similar in aim to tools like [Checkstyle](http://checkstyle.sourceforge.net), [PMD](http://pmd.sourceforge.net) or [Findbugs](http://findbugs.sourceforge.net), but the analogy ends here. While the above mentioned tools work by scanning the source code in search for errors, JBSE works by simulating the execution of compiled classes (that's why it is a Java Virtual Machine) and analyzing all the conditions that may lead to the coverage of prescribed bytecode instructions. In practice, JBSE expect that you specify the verification properties of interest for your project, by means of *assumptions* and *assertions*. Assumptions specify the conditions that must be satisfied for an execution to be relevant, while assertions specify the conditions that must satisfied for an execution to be correct. JBSE then attempts to determine whether some program inputs satisfying all the assumptions make fail at least one assertion. In this regard JBSE is a hybrid, static/dynamic analysis tool more similar in spirit, implementation and mode of use to tools like [Symbolic PathFinder](http://babelfish.arc.nasa.gov/trac/jpf/wiki/projects/jpf-symbc), [Sireum/Kiasan](http://www.sireum.org) and [JNuke](http://fmv.jku.at/jnuke/).\r\n\r\n### What are its distinctive features?\r\nSpecifying good verification properties is not always easy, especially when inputs are complex object configurations as customarily happen with object oriented and heap manipulating programs. JBSE helps you in this task by offering a comprehensive set of techniques and languages for expressing assumptions and assertions. None of the tools we are currently aware of offers all of them. This allows JBSE to execute and analyze a wide spectrum of Java programs, including programs that manipulate arrays.\r\n\r\nAnother feature of JBSE is its speed. According to our microbenchmarks it is among the fastest symbolic executors for Java bytecode. Of course you must consider all the standard caveats about the (scarce) generality of microbenchmarks, but we have not yet encountered a case study where JBSE is meaningfully slower than other approaches.\r\n\r\n### What are its limitations?\r\nDetermining whether a control-flow path in the program can be covered by some inputs is an intrinsically hard problem, much harder than scanning the code for bug patterns. JBSE calculates *path conditions*, that is, formulas on the input variables whose solutions, if they exist, are the inputs that cover a program path. Then, JBSE checks whether the path conditions have solutions by invoking an external solver. Currently JBSE can interact with [Sicstus CLP](https://sicstus.sics.se) and with the SMT solvers [Z3](http://z3.codeplex.com) and [CVC3](http://www.cs.nyu.edu/acsys/cvc3/). The correctness, completeness and speed of JBSE strongly depend on those of the solver it relies upon. \r\n\r\nApart from solvers limitations, JBSE also has limitations on its own. JBSE follows the [Java Virtual Machine specification v.2](https://docs.oracle.com/javase/specs/jvms/se5.0/html/VMSpecTOC.doc.html), and does not implement successive extensions as, e.g., the invokedynamic bytecode. JBSE is not even completely compliant with the Java Virtual Machine specification v.2. Some features that JBSE does not implement, or implements only in part, are multithreading, locking (JBSE only analyzes single-threaded code), reflection and dynamic class loading. Moreover JBSE is not currently able to execute most of the Java standard library, although we plan to progressively improve it under this aspect.\r\n\r\n### Authors and Contributors\r\nThe contributions to JBSE extend over a very long period. The current maintainer of JBSE is Pietro Braione (@pietrobraione), with contributions by Giovanni Denaro especially on the rewriting engine. Marco Gaboardi wrote the initial implementation of JBSE. Diego Piazza contributed to develop the Z3 interface.\r\n\r\n### Disclaimer\r\nJBSE is a research prototype offered as-is, and we disclaim any expressed or implied warranty on its correctness, quality, or even fitness for a particular purpose. By using JBSE you implicitly acknowledge its authors and the organization they belong to as non liable for any direct or consequent damage that may derive from its use, for any definition of liability. See the [license](https://github.com/pietrobraione/jbse/blob/master/LICENSE.txt) for more information.\r\n\r\n### More information\r\nA user manual is still not available. In the meantime you can refer to the publications section at the [homepage of Pietro Braione](https://sites.google.com/site/pietrobraione/home).\r\n\r\n### Support or Contact\r\nFor any issue contact Pietro Braione at *name*.*surname*@unimib.it.","google":"UA-33854666-2","note":"Don't delete this file! It's used internally to help with page regeneration."}